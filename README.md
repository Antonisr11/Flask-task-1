# 1η υποχρεωτική εργασία εξαμήνου

Δεν είναι ακόμα έτοιμο. Σύντομα κοντά σας
-

## Περιεχόμενα 
* [Γενικά](#General)
* [Ερώτημα 1](#Task_1) 
* [Ερώτημα 2](#Task_2)
* [Ερώτημα 3](#Task_3)
* [Ερώτημα 4](#Task_4)
* [Ερώτημα 5](#Task_5)
* [Ερώτημα 6](#Task_6)
* [Ερώτημα 7](#Task_7)
* [Ερώτημα 8](#Task_8)
* [Ερώτημα 9](#Task_9)

## General
Το προγραμμά διαχειρίζεται μέσω flask μία βάση δεδομένων που κρατάει στοιχεία για κάποιους μαθητές. Η βάση δεδομένων υλοποιείται μέσω της MongoDB.

## Changes
### Αλλαγές στον κωδικά που λάβαμε
Κατά την εκπόνηση της εργασίας εντοπίστηκαν κάποια λάθη και διορθώθηκαν. Ας δούμε ποια ήταν αυτά:

1 Στο ερώτημα 4 στο app route '/getStudents/thirties' έλειπε ένα '=' από το όρισμα methods
2 Στο ερώτημα 5 στο app route '/getStudents/oldies' έλειπε ένα '=' από το όρισμα methods
3 Στο ερώτημα 5 η συνάρτηση είχε το ίδιο όνομα με την συνάρτηση του ερωτήματος 4
4 Στο ερώτημα 6 η συνάρτηση είχε το ίδιο όνομα με την συνάρτηση του ερωτήματος 3
5 Στο ερώτημα 7 υπήρχε σαν μέθοδος 'DELETE', λόγω error το αλλάξαμε σε GET
6 Στο ερώτημα 8 υπήρχε σαν μέθοδος 'PATCH', λόγω error το αλλάξαμε σε GET

## Task_1
### ΕΡΩΤΗΜΑ 1: Δημιουργία χρήστη
Αρχικά ελέγχουμε αν υπάρχει χρήστης με το ίδιο username. Αυτό το υλοποιούμε με το να μετράμε τους users που έχουν έχουν το username που πήραμε σαν όρισμα.
-> Αν ο αριθμός αυτός βγει 0 τότε εισάγουμε τον user στην βάση δεδομένων και επιστρέφεται μήνυμα που ενημερώνει τον χρήστη για την επιτυχή εισαγωγή
-> Αν δεν βγει 0, εμφανίζεται μήνυμα λάθους καθώς υπάρχει ήδη κάποιος στην βάση με αυτό το username

## Task_2
### ΕΡΩΤΗΜΑ 2: Login στο σύστημα
Σε αυτή την συνάρτηση θέλουμε να ελέγξουμε αν υπάρχει κάποιος χρήστης με το username και το password που λάβαμε σαν όρισμα. Ακολουθούμε την ίδια νοοτροπία με το ερώτημα 1, δηλαδή μετράμε πόσους users έχει η βάση με αυτά τα στοιχεία (χρησιμοποιουμε and καθώς θέλουμε ίδιο username και password).
-> Αν ο αριθμός βγει 1 ή πιο συγκεκριμένα αν δεν βγει 0, τότε έχουμε αυθεντικοποιήσει τον χρήστη.
-> Σε κάθε άλλη ο χρήστης δεν θα αυθεντικοποιηθεί και επιστρέφεται μήνυμα λάθους

Αν αυθεντικοποιηθεί ο χρήστης, το username του περνάει σε μία συνάρτηση create_session και μέσα σε αυτή δημιουργείται ένα μοναδικό id (για το username) το οποίο αποθηκεύεται στην λίστα users_sessions. Το id αυτό μαζί με το username εκτυπωνονται στον χρήστη. 

## Task_3
### ΕΡΩΤΗΜΑ 3: Επιστροφή φοιτητή βάσει email
Πριν αναλύσουμε το ερώτημα αυτό θα εξηγήσουμε πλήρως πως ελέγχουμε την αυθεντικοποίηση του χρήστη καθώς στα επόμενα ερωτήματα που ζητάνε όλα αυθεντικοποίηση δεν το εξηγήσουμε εκ νέου αφού η υλοποίηση είναι η ίδια.

Στο ερώτημα αυτό ζητάμε αυθεντικοποίηση χρήστη, δηλαδή ο χρήστης να έχει κάνει login. Όπως αναφέραμε και στην υλοποίηση του login, μετά την επιτυχή εισαγωγή username και password μας επιστρέφεται ένα id που βρίσκεται στην λίστα users_sessions. Οπότε στα headers του request που έχει γίνει, βρίσκουμε αυτό το id. Έπειτα το περνάμε από την συνάρτηση is_session_valid που μας επιστρέφει αν το id είναι έγκυρο δηλαδή αν όντως έχει γίνει login.
Αν μας επιστρέψει True είναι έγκυρο και συνεχίζουμε με τα ζητούμενα του ερωτήματος αλλιώς τυπώνεται το μήνυμα "You haven't been authenticated" με status 401.

Αφού λοιπόν αυθεντικοποιήσουμε τον χρήστη ψάχουμε για κάποιον φοιτητή με το email που λάβαμε στα data του request. Χρησιμοιποιούμε την εντολή find_one καθώς ενδιαφερόμαστε για έναν μόνο φοιτητή. Το αποτέλεσμα της αναζήτησης αποθηκεύεται σε μια μεταβλήτή student.

-> Αν το student είναι None τότε σημαίνει πως δεν βρέθηκε κανένας με αυτό το mail. Οπότε επιστρέφεται το ανάλογο μήνυμα
-> Αν το student έχει δεδομένα τότε θα είναι ένα JSON με τα στοιχεία του μαθητή που έχει το mail που ψάχναμε. Θέτουμε το πεδίο \_id του student ίσο με None (αφού το \_id δείχνει σε Object και αυτό χαλάει την μορφή του JSON) και τα στοιχεία του φοιτητή εκτυπώνονται στον χρήστη.

## Task_4
### ΕΡΩΤΗΜΑ 4: Επιστροφή όλων των φοιτητών που είναι 30 ετών
Αφού αυθεντικοποιηθεί ο χρήστης (βλέπουμε [Ερώτημα 3](#Task_3)) βρίσκουμε όλους τους φοιτητές με ηλικία 30 χρονών. Ουσιαστικά αναζητούμε την χρονιά της γέννησής τους και αυτό γίνεται με την βιβλιοθήκη date όπου παίρνουμε την φετινή χρονιά και της αφαιρούμε 30. πχ αν φέτος έχουμε 2021 θα ψάξουμε για φοιτητές γεννημένους το 1991 (2021 - 30 = 1991).
Σε αυτούς που έχουν γεννηθεί στην χρονιά που θα προκύψει, θέτουμε το \_id = None

-> Αν υπάρχει τουλάχιστον ένας φοιτητής με αυτή την χρονιά γέννησης επιστρέφονται τα στοιχεία του μαθητή / των μαθητών στον χρήστη.
-> Αν δεν βρεθεί κανένας θα επιστραφεί ένα ανάλογο μήνυμα

## Task_5
### ΕΡΩΤΗΜΑ 5: Επιστροφή όλων των φοιτητών που είναι τουλάχιστον 30 ετών
Αφού αυθεντικοποιηθεί ο χρήστης (βλέπουμε [Ερώτημα 3](#Task_3)) βρίσκουμε όλους τους φοιτητές με ηλικία μεγαλύτερη ή ίση των 30 χρονών. Ακολουθούμε την ίδια νοοτροπία με το ερώτημα 4 με την μόνη διαφορά πως αφού βρούμε την φετινή χρονολογία και τις αφαιρέσουμε 30, ψάχουμε για ημερομηνίες μικρότερες ή ίσες από αυτή. 

-> Αν υπάρχει τουλάχιστον ένας φοιτητής που ανήκει στο σύνολο 30+ επιστρέφονται τα στοιχεία του μαθητή / των μαθητών στον χρήστη.
-> Αν δεν βρεθεί κανένας θα επιστραφεί ένα ανάλογο μήνυμα

## Task_6
### ΕΡΩΤΗΜΑ 6: Επιστροφή φοιτητή που έχει δηλώσει κατοικία βάσει email
Αφού αυθεντικοποιηθεί ο χρήστης (βλέπουμε [Ερώτημα 3](#Task_3)) ψάχνουμε με την συνάρτηση find_one για έναν μαθητή με το e-mail που παίρνουμε σαν όρισμα. Για να κάνουμε τον κώδικα πιο μικρό αλλά και για να αποφύγουμε περριτούς ελέγχους σε αυτό το ερώτημα το έχουμε υλοποιήσει με διαφορετικό τρόπο από τα προηγούμενα. 

Σε περίπτωση που δεν υπάρχει μαθητής με αυτό το e-mail αλλά και αν υπάρχει χωρίς να έχει δηλώσει την διεύθυνσή του, το μήνυμα λάθους είναι το ίδιο. Οπότε επιστρέφουμε τα στοιχεία του μαθητή (όνομα, διεύθυνση και ταχυδρομικός κώδικας) μέσα σε try και στο except έχουμε ένα μήνυμα λάθους. Οπότε:
-> Σε περίπτωση που υπάρχει μαθητής με αυτό το e-mail και έχει δηλωμένη διεύθυνση θα επιστραφεί κανονικά στον χρήστη ένα JSON με το όνομά του, την διεύθυνσή του και τον ταχυδρομικό του κώδικα
-> Σε περίπτωση που ο φοιτητής αυτός δεν έχει δηλώσει διεύθυνση, όταν θα ζητηθεί το πεδίο 'address' θα υπάρξει Exception οπότε θα εκτελεστεί το except που περιέχει το μήνυμα λάθους
-> Σε περίπτωση που το e-mail δεν αντιστοιχίζεται σε κάποιον φοιτητή, η μεταβλητή student θα είναι None και δεν θα υπάρχει κανένα πεδίο. Όταν του ζητηθεί κάποιο πεδίο θα εκτελεστεί το except που περιέχει το μήνυμα λάθους

## Task_7
### ΕΡΩΤΗΜΑ 7: Διαγραφή φοιτητή βάσει email
Αφού αυθεντικοποιηθεί ο χρήστης (βλέπουμε [Ερώτημα 3](#Task_3)) ψάχνουμε με την συνάρτηση find_one_and_delete για έναν μαθητή με το e-mail που παίρνουμε σαν όρισμα και έπειτα αυτός διαγράφεται από την βάση δεδομένων. Η συνάρτηση find_one_and_delete όταν διαγράφει κάποιον μαθητή επιστρέφει τα στοιχεία του και αν δεν τον βρει επιστρέφει None. Οπότε ελέγχουμε αν αυτό που επιστρέφει η συνάρτηση είναι None ή όχι.

-> Σε περίπτωση που δεν είναι None θέτουμε σε μία μεταβλητή msg ένα μήνυμα επιτυχούς διαγραφής και σε μία μεταβλητή status τον αριθμό 200
-> Σε περίπτωση που είναι None θέτουμε σε μία μεταβλητή msg ένα μήνυμα αποτυχίας και σε μία μεταβλητή status τον αριθμό 400

Έπειτα επιστρέφουμε στον χρήστη την μεταβλητή msg με status ίσο με τον αριθμό από κάθε περίπτωση.

## Task_8
### ΕΡΩΤΗΜΑ 8: Εισαγωγή μαθημάτων σε φοιτητή βάσει email
Αφού αυθεντικοποιηθεί ο χρήστης (βλέπουμε [Ερώτημα 3](#Task_3)) ψάχνουμε με την συνάρτηση find_one_and_update για έναν μαθητή με το e-mail που παίρνουμε σαν όρισμα και έπειτα σε αυτόν προστίθονται τα courses που επίσης έχουμε πάρει σαν όρισμα. Όπως και στο [Ερώτημα 8](#Task_8) έτσι και εδώ ελέγχουμε αν αυτό που επιστρέφει η συνάρτηση είναι None. Γιατί αν είναι None σημαίνει ότι δεν βρήκε τον μαθητή ενώ σε άλλη περίπτωση σημαίνει ότι τον έχει βρει. Αξίζει να επισημάνουμε πως αν ο μαθητής έχει ήδη courses τα καινούργια θα αντικαταστήσουν τα παλιά (δεν υπάρχει έλεγχος γιατί μπορεί να πρέπει να διορθωθεί κάποιος βαθμός ή να προστεθεί).

-> Σε περίπτωση που είναι None το αποτέλεσμα της συνάρτησης find_one_and_update επιστρέφεται μήνυμα αποτυχίας 
-> Σε κάθε άλλη περίπτωση επιστρέφεται μήνυμα επιτυχής εισαγωγής των βαθμών στον μαθητή

## Task_9
### ΕΡΩΤΗΜΑ 9: Επιστροφή περασμένων μαθημάτων φοιτητή βάσει email
Το ερώτημα αυτό θα το χωρίσουμε σε 4 στάδια.

Στάδιο 1 - Αυθεντικοποίηση χρήστη
Αρχικά αυθεντικοποιείται ο χρήστης (βλέπουμε [Ερώτημα 3](#Task_3))

Στάδιο 2 - Εύρεση του μαθητή
Τώρα θα πρέπει να βρούμε τον μαθητή με το e-mail που έχουμε σαν όρισμα και να ελέγξουμε αν αυτός έχει περασμένα μαθήματα. Για να τα συμπικνώσουμε όλα αυτά σε μια εντολή χρησιμοποιούμε την συνάρτηση find_one και μέσα σε αυτήν βάζουμε 2 φίλτρα με and καθώς θέλουμε να ισχύουν και τα 2. Το 1ο φίλτρο μας διασφαλίζει ότι ο μαθητής έχει δηλωμένα μαθήματα (ελέγχει αν υπάρχει το πεδίο 'courses' και αυτό δεν είναι null) και το 2ο ότι το e-mail που έχουμε σαν όρισμα είναι του φοιτητή αυτού. Το αποτέλεσμα αυτό το αποθηκεύουμε σε μία μεταβλητή student. 

-> Σε περίπτωση που η μεταβλητή student είναι None τότε δεν υπάρχει μαθητής με αυτά τα κριτήρια και επιστρέφεται το ανάλογο μήνυμα
-> Σε κάθε άλλη περίπτωση υπάρχει μαθητής με αυτό το e-mail και με δηλωμένα μαθήματα, οπότε περνάμε στο επόμενο στάδιο

Στάδιο 3 - Build του JSON
Σε αυτό το στάδιο θα "χτίσουμε" τα στοιχεία του μαθητή. Σαν απάντηση στον χρήστη πρέπει να στείλουμε ένα JSON με τα περασμένα μαθήματα του μαθητή που μπορεί να μέρος των μαθημάτων που έχουν δηλωθεί, οπότε αναγκαστικά θα ελέγξουμε όλα τα μαθήματα και θα προσθέτουμε στο JSON τα μαθήματα που έχουν βαθμό μεγαλύτερο ή ίσο του 5. 
Οπότε έχουμε ένα string με το όνομα student_build το οποίο είναι σε μορφή JSON. Ελέγχουμε ένα προς ένα όλα τα μαθήματα και όποιο έχει βαθμό μεγαλύτερο ή ίσο του 5 προστίθεται στο student_build χωρίς να χαλάει η συνοχή του JSON. 

Στάδιο 4 - Αποστολή αποτελεσμάτων στον χρήστη
Στο προηγούμενο στάδιο παραλείψαμε να αναφέρουμε πως υπάρχει μια flag μεταβλητή has_passed_at_least_one που είναι true μόνο αν ο μαθητής έχει περάσει τουλάχιστον ένα μάθημα. Οπότε:
-> Σε περίπτωση που το has_passed_at_least_one είναι true επιστρέφεται στον χρήστη το student_build (στην υλοποίηση επιστρέφεται η μεταβλητή student που είναι ουσιαστικά το student_build αφότου το μετατρέψουμε από string σε JSON)
-> Σε περίπτωση που το has_passed_at_least_one είναι false επιστρέφεται μήνυμα που αναφέρει ότι ο μαθητής δεν έχει περάσει κανένα μάθημα
















